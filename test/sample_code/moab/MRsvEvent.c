/* HEADER */

      
/**
 * @file MRsvEvent.c
 *
 * Contains: Reservation Event functions
 */

#include "moab.h"
#include "moab-proto.h"  
#include "moab-const.h"  
#include "moab-global.h"  

/**
 * Converts a linked-list of reservation events to an array.
 *
 * NOTE: Array must be freed be caller
 *       Size is the size of the allocated array
 * 
 * @see MRsvAdjustDRes - parent
 *
 * @param List (I)
 * @param Array (O) - must be freed by caller
 * @param Size (O) - size of array being returned
 */

int MREListToArray(

  mre_t  *List,
  mre_t **ArrayP,
  int    *SizeP)

  {
  mre_t *RE;
  mre_t *Array = NULL;

  int index;

  if (SizeP != NULL)
    *SizeP = 0;

  if (List == NULL)
    {
    return(SUCCESS);
    }

  if ((ArrayP == NULL) || (SizeP == NULL))
    {
    return(SUCCESS);
    }

  /* size is difficult to calculate, you can have multiple starts and ends for
     admin reservations, just use MMAX_RSV_GDEPTH for now */

  MREAlloc(&Array,MMAX_RSV_GDEPTH);

  index = 0;

  for (RE = List;RE != NULL;MREGetNext(RE,&RE))
    {
    MRECopyEvent(&Array[index++],RE,TRUE);
    }

  Array[index].Type = 0;
  Array[index].R = NULL;
  Array[index].TC = 0;
  Array[index].Time = 0;

  *SizeP = MMAX_RSV_GDEPTH;
  *ArrayP = Array;

  return(SUCCESS);
  }  /* END MREListToArray() */



/**
 * Returns TRUE if the Node has a partial (proc) user reservation.
 *
 * @param N (I)
 */

mbool_t MNodeHasPartialUserRsv(

  mnode_t *N)

  {
  mre_t *RE;

  if ((N == NULL) || (N->RE == NULL))
    return(FALSE);

  for (RE = N->RE;RE != NULL;MREGetNext(RE,&RE))
    {
    if (RE->Type != mreStart)
      continue;

    if (RE->R->Type != mrtUser)
      continue;

    if (RE->R->DRes.Procs == -1)
      continue;

    if (RE->R->DRes.Procs == N->CRes.Procs)
      continue;

    if (RE->R->DRes.Procs * RE->TC == N->CRes.Procs)
      continue;

    return(TRUE);
    }

  return(FALSE);
  }  /* END MREListHasPartialUserRsv() */



int MRECopyEvent(

  mre_t   *Dst,
  mre_t   *Src,
  mbool_t  CopyRes)

  {
  Dst->Time   = Src->Time;
  Dst->Type   = Src->Type;
  Dst->R      = Src->R;
  Dst->TC     = Src->TC;
  
  if (CopyRes == TRUE)
    MCResCopy(&Dst->BRes,&Src->BRes);

  return(SUCCESS);
  }  /* END MRECopyEvent() */


int MRECopy(

  mre_t   *Dst,
  mre_t   *Src,
  int      Size,
  mbool_t  CopyRes)

  {
  int index;

  for (index = 0;index < Size;index++)
    {
    MRECopyEvent(&Dst[index],&Src[index],CopyRes);
    }
  
  return(SUCCESS);
  }  /* END MRECopy() */




int MREAlloc(

  mre_t **RE,
  int     Size)

  {
  int rindex;

  mre_t *tmpRE;

  if ((RE == NULL) || (Size <= 0))
    {
    return(FAILURE);
    }

  tmpRE = (mre_t *)MUCalloc(1,sizeof(mre_t) * Size);

  for (rindex = 0;rindex < Size;rindex++)
    {
    MSNLInit(&tmpRE[rindex].BRes.GenericRes);
    }

  *RE = tmpRE;

  return(SUCCESS);
  }  /* END MREAlloc() */




int MREAddSingleEvent(

  mre_t **REHead,
  mre_t  *RE)

  {
  if (RE == NULL)
    {
    return(FAILURE);
    }

  mre_t *ptr;
  mre_t *prev;

  /* initial setup of pointers */

  prev = NULL;

  ptr = *REHead;

  while (ptr != NULL)
    {
    prev = ptr;   /* Save a pointer to the current node, as we walk the list */

    ptr = ptr->Next;
    }  /* END while (ptr != NULL) */

  /* reached end of list so we are adding new element to linked list */

  /* Get a new control structure */
  if ((ptr = (mre_t *)MUCalloc(1,sizeof(mre_t))) == NULL)
    {
    return(FAILURE);
    }

  if (MCResInit(&ptr->BRes) == FAILURE)
    {
    return(FAILURE);
    }

  /* Check if list has nodes or is empty, and adjust ptrs accordingly */
  if (prev != NULL)
    {
    prev->Next = ptr;
    }
  else
    {
    /* This case is generated by an empty RE table */

    *REHead = ptr;
    }

  /* fill in the new control node */

  MRECopyEvent(ptr,RE,TRUE);

  *REHead = MRESort(*REHead);

  return(SUCCESS);
  }  /* END MREInsertSingleEvent() */
 


/**
 * Insert new event into specified global/per-node event table
 *
 * @param RE (I) [array modified]
 * @param StartTime (I)
 * @param EndTime (I)
 * @param RsvIndex (I)
 * @param R () (optional)
 * @param DRes (I)
 * @param TableSize (I)
 */

int MREInsert(

  mre_t  **RE,
  long     StartTime,
  long     EndTime,
  mrsv_t  *R,
  mcres_t *DRes,
  int      TC)

  {
  mre_t tmpRE;

  if (RE == NULL)
    {
    return(FAILURE);
    }

  MRERelease(RE,R);

  memset(&tmpRE,0,sizeof(tmpRE));

  MCResInit(&tmpRE.BRes);

  tmpRE.TC = TC;
  tmpRE.R  = R;
  MCResCopy(&tmpRE.BRes,DRes);
  tmpRE.Time = StartTime;
  tmpRE.Type = mreStart;

  MREAddSingleEvent(RE,&tmpRE);

  tmpRE.Time = EndTime;
  tmpRE.Type = mreEnd;
  
  MREAddSingleEvent(RE,&tmpRE);

  MCResFree(&tmpRE.BRes);

#if 0

  /* NOTE:  only one start/end pair per job/user RE at creation time */

  if (RE[0].Type == mreNONE)
    {
    RE[0].Time  = StartTime;
    RE[0].Type  = mreStart;
    RE[0].Index = RsvIndex;
    RE[0].R     = R;
    MCResCopy(&RE[0].BRes,DRes);

    RE[1].Time  = EndTime;
    RE[1].Type  = mreEnd;
    RE[1].Index = RsvIndex;
    RE[1].R     = R;
    MCResCopy(&RE[1].BRes,DRes);

    RE[2].Type  = mreNONE;
    }
  else
    {
    /* locate last rsv-event */

    for (index = 0;index < TableSize;index++)
      {
      if (RE[index].Type == mreNONE)
        {
        /* terminate list at new end point */

        RE[MIN(index + 2,TableSize)].Type = mreNONE;

        break;
        }
      }    /* END for (index) */

    if (index == TableSize)
      {
      MDB(3,fSCHED) MLog("ALERT:    RE table overflow detected - increase %s (MAX=%d)\n",
        MParam[mcoMaxRsvPerNode],
        TableSize);

      MSched.NodeREOverflowDetected = TRUE;

      return(FAILURE);
      }

    /* insert end event */

    startindex = MAX(0,index - 1);

    EndLocated = FALSE;

    for (index = startindex;index >= 0;index--)
      {
      if (EndTime >= RE[index].Time)
        {
        /* insert end event */

        RE[index + 2].Time  = EndTime;
        RE[index + 2].Type  = mreEnd;
        RE[index + 2].Index = RsvIndex;
        RE[index + 2].R     = R;

        MCResCopy(&RE[index + 2].BRes,DRes);

        EndLocated = TRUE;

        break;
        }

      MRECopyEvent(&RE[index + 2],&RE[index],TRUE);
      }    /* END for (index) */

    if (EndLocated == FALSE)
      {
      RE[1].Time  = EndTime;
      RE[1].Type  = mreEnd;
      RE[1].Index = RsvIndex;
      RE[1].R     = R;

      MCResCopy(&RE[1].BRes,DRes);
      }

    /* insert start event */

    startindex = index;

    for (index = startindex;index >= 0;index--)
      {
      if (StartTime >= RE[index].Time)
        {
        /* insert start event */

        RE[index + 1].Time  = StartTime;
        RE[index + 1].Type  = mreStart;
        RE[index + 1].Index = RsvIndex;
        RE[index + 1].R     = R;

        MCResCopy(&RE[index + 1].BRes,DRes);

        break;
        }

      MRECopyEvent(&RE[index + 1],&RE[index],TRUE);
      }   /* END for (index) */

    /* prepend start event if necessary */

    if (StartTime < RE[0].Time)
      {
      RE[0].Time  = StartTime;
      RE[0].Type  = mreStart;
      RE[0].Index = RsvIndex;
      RE[0].R     = R;

      MCResCopy(&RE[0].BRes,DRes);
      }
    }   /* END else (RE[0].Type == mreNONE) */
#endif

  return(SUCCESS);
  }  /* END MREInsert() */





/**
 * Remove reservation event entry.
 *
 * @see MREInsert()
 *
 * @param RE (I)
 * @param R (I) [optional]
 */

int MRERelease(

  mre_t **RHead,
  mrsv_t *R)

  {
  /* NOTE:  assume local copy made to address threading issues/race conditions */

  mre_t *Prev;
  mre_t *ptr;
  mre_t *next;

  mbool_t FoundName = FALSE;

  if ((RHead == NULL) || (R == NULL) || (*RHead == NULL))
    {
    return(FAILURE);
    }

  Prev = NULL;

  next = (*RHead)->Next;

  for (ptr = *RHead;ptr != NULL;ptr = next)
    {
    if (ptr->R == NULL)
      break;

    if (R != ptr->R)
      {
      /* current node does not match */

      Prev = ptr;

      next = ptr->Next;

      continue;
      }

    /* relink tree */

    if (Prev == NULL)
      {
      /* new head */

      *RHead = ptr->Next;
      }
    else
      {
      Prev->Next = ptr->Next;
      }

    /* free object */

    next = ptr->Next;

    MCResFree(&ptr->BRes);
    MUFree((char **)&ptr);

    FoundName = TRUE;
    }  /* END for (ptr) */

  if (FoundName == TRUE)
    return(SUCCESS);
  else
    return(FAILURE);

#if 0
  int reindex;

  int Offset;

  if (RE == NULL)
    {
    return(FAILURE);
    }

  /* release all reservation events referencing a particular reservation */

  Offset = 0;

  for (reindex = 0;reindex < TableSize;reindex++)
    {
    if (RE[reindex].Type == mreNONE)
      break;

    if ((RIndex >= 0) && (RE[reindex].Index == RIndex))
      {
      Offset++;

      continue;
      }

    if ((R != NULL) && (RE[reindex].R == R))
      {
      Offset++;

      continue;
      }

    if (Offset > 0)
      {
      MRECopyEvent(&RE[reindex - Offset],&RE[reindex],TRUE);
      }
    }  /* END for (reindex) */

  /* terminate RE table */

  RE[reindex - Offset].Type = mreNONE;

  return(SUCCESS);
#endif
  }  /* END MRERelease() */


int MREFree(

  mre_t **Head)

  {
  mre_t *ptr;
  mre_t *next;

  /* free linked list */

  if ((Head == NULL) || (*Head == NULL))
    {
    return(SUCCESS);
    }

  /* Walk the entire list, cleaning each node on the list */
  for (ptr = *Head;ptr != NULL;ptr = next)
    {
    /* If BRes was allocated, free it */

    MCResFree(&ptr->BRes);

    /* Note next node after current one */

    next = ptr->Next;

    /* Finally, free the node's control structure */

    MUFree((char **)&ptr);
    }  /* END for (ptr) */

  *Head = NULL;   /* Clear the head pointer when all is said and done */

  return(SUCCESS);
  }  /* END MREFree() */



mrsv_t *MREGetRsv(

  mre_t *RE)

  {
  if ((RE == NULL) || (RE->R == NULL) || (RE->R == (mrsv_t *)1) || (!isprint(RE->R->Name[0])))
    {
    return(NULL);
    }

  return(RE->R);
  }  /* END MREGetRsv() */





int __MRESortCmp(

  mre_t *A,
  mre_t *B)

  {
  return(A->Time > B->Time);
  }  /* END __MRESortCmp() */



/**
 * Return SUCCESS if R within RE, optionally populate TC.
 *
 * @param RE (I) required
 * @param R (I) required
 * @param TC (O) optional
 */

int MREFindRsv(

  mre_t  *RE,
  mrsv_t *R,
  int    *TC)

  {
  mre_t *tRE;

  if ((RE == NULL) || (R == NULL))
    {
    return(FAILURE);
    }

  if (TC != NULL)
    *TC = 0;

  for (tRE = RE;tRE != NULL;MREGetNext(tRE,&tRE))
    {
    if (MREGetRsv(tRE) == R)
      {
      if (TC != NULL)
        *TC = tRE->TC;

      return(SUCCESS);
      }
    }
 
  return(FAILURE);
  }  /* END MREFindRsv() */




mre_t *MRESort(

  mre_t *list)

  {
  mre_t *p, *q, *e, *tail;

  int insize, nmerges, psize, qsize, i;

  /*
   * Silly special case: if `list' was passed in as NULL, return
   * NULL immediately.
   */
  if (!list)
      return NULL;

  insize = 1;

  while (1) 
    {
    p = list;
    list = NULL;
    tail = NULL;

    nmerges = 0;  /* count number of merges we do in this pass */

    while (p) 
      {
      nmerges++;  /* there exists a merge to be done */
      /* step `insize' places along from p */
      q = p;
      psize = 0;
      for (i = 0; i < insize; i++) 
        {
        psize++;

        q = q->Next;

        if (!q) break;
        }

      /* if q hasn't fallen off end, we have two lists to merge */
      qsize = insize;

      /* now we have two lists; merge them */
      while (psize > 0 || (qsize > 0 && q)) 
        {
        /* decide whether next element of merge comes from p or q */
        if (psize == 0) 
          {
          /* p is empty; e must come from q. */
          e = q; q = q->Next; qsize--;
          }
        else if (qsize == 0 || !q) 
          {
          /* q is empty; e must come from p. */
          e = p; p = p->Next; psize--;
          } 
        else if (__MRESortCmp(p,q) <= 0) 
          {
          /* First element of p is lower (or same);
           * e must come from p. */
          e = p; p = p->Next; psize--;
          } 
        else 
          {
          /* First element of q is lower; e must come from q. */
          e = q; q = q->Next; qsize--;
          }

        /* add the next element to the merged list */
        if (tail) 
          {
          tail->Next = e;
          } 
        else 
          {
          list = e;
          }

        tail = e;
        } /* END while (psize > 0 || (qsize > 0 && q)) */

      /* now p has stepped `insize' places along, and q has too */
      p = q;
      }  /* END while (p) */

    tail->Next = NULL;

    /* If we have done only one merge, we're finished. */
    if (nmerges <= 1)   /* allow for nmerges==0, the empty list case */
      {
      return list;
      }

    /* Otherwise repeat, merging lists twice the size */
    insize *= 2;
    }  /* END while (1) */
  }  /* END MRESort() */


/**
 * Populate REP with the next event in RE.
 * 
 * @param RE
 * @param REP
 */

int MREGetNext(

  mre_t  *RE,
  mre_t **REP)
 
  {
  if (REP != NULL)
    *REP = NULL;

  if ((RE == NULL) || (REP == NULL))
    {
    return(FAILURE);
    }

  *REP = RE->Next;

  return(SUCCESS);
  }

/* END MRsvEvent.c */
