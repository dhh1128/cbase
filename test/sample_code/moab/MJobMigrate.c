/* HEADER */

      
/**
 * @file MJobMigrate.c
 *
 * Contains: Job Mirgration functions
 */

#include "moab.h"
#include "moab-proto.h"  
#include "moab-const.h"  
#include "moab-global.h"  



/**
 * Attempt to migrate job from its current Resource Manager (RM) to a different RM.
 * a different RM.
 * 
 * NOTE:  If job has specified WorkloadRM, migrate to WorkloadRM instead of specified RM.
 *
 * NOTE:  Use of DoPurgeSource causes source job to be removed upon
 *        successful completion allowing migrated jobs to be newly discovered
 *        via RM interface and job to be properly initialized via
 *        MRMJobPreLoad()/M*JobLoad(), etc.  It is currently only used
 *        in conjunction with the 'INSTANTSTAGE TRUE' parameter.
 *
 * NOTE:  Available resources within target partition will be reduced by the 
 *        resource amount requested by the job.
 *
 * @see MRMJobSubmit() - child
 *
 * NOTE:  Used to migrate/submit job to specified RM - NOT used to migrate
 *        job tasks from one physical node to another - see MRMJobMigrate()
 *
 * @param JP (I/O) The job that will be migrated. If successfully migrated,
 *        will point to the new job.
 * @param SpecR (I) The RM that the job should be moved to.
 * @param DoPurgeSource (I) Remove source job after job submit/migrate
 *        is successful.
 * @param JobID (I, Optional) The job id that the migrated job should use.
 * @param EMsg (O, Optional) Any error message generated by this function will
 *        be put into this buffer.
 * @param SC (O, Optional) Some kind of status code? 
 */

int MJobMigrate(

  mjob_t              **JP,            /* I/O (modified) points to new job if successful */
  mrm_t                *SpecR,         /* I (target/dest RM) */
  mbool_t               DoPurgeSource, /* I - remove source job after job submit/migrate is successful */
  char                 *JobID,         /* I (optional,minsize=MMAX_NAME) new jobid - use if Purge==TRUE */
  char                 *EMsg,          /* O (optional,minsize=MMAX_LINE, minsize=MMAX_BUFFER if mjfTest) */
  enum MStatusCodeEnum *SC)            /* O (optional) */

  {
  char  FullJobID[MMAX_LINE];    /* represents DRM job id for master
                                    req (req[0]) */
  char  SJobID[MMAX_NAME];

  /* enum MStatusCodeEnum tSC = mscNoError; */

  mjob_t *SJ;  /* original source job */
  mjob_t *J;
  mpar_t *P;
  mjob_t *JA = NULL;

  int   rc;
  int   rqindex;

  mrm_t *R;

  mreq_t *RQ;
  mrm_t  *NRM;

  mnode_t *N;

  const char *FName = "MJobMigrate";

  MDB(5,fSCHED) MLog("%s(%s,%s,%s,%s,EMsg,SC)\n",
    FName,
    ((JP != NULL) && (*JP != NULL)) ? (*JP)->Name : "NULL",
    (SpecR != NULL) ? SpecR->Name : "NULL",
    MBool[DoPurgeSource],
    (JobID != NULL) ? JobID : "NULL");

  if (EMsg != NULL)
    EMsg[0] = '\0';

  if (SC != NULL)
    *SC = mscNoError;

  /* move job to specified rm */

  if ((JP == NULL) || (*JP == NULL) || (SpecR == NULL))
    {
    if (EMsg != NULL)
      strcpy(EMsg,"internal error - invalid parameters");

    return(FAILURE);
    }

  if (JobID != NULL)
    JobID[0] = '\0';

  FullJobID[0] = '\0';

  SJ = *JP;

  J = SJ;

  J->MigrateBlockReason = mjneNONE;

  /* don't migrate master of job array */
  if (J->Array != NULL)
    {
    return(SUCCESS);
    }

  J->MigrateCount++;

  if ((J->TemplateExtensions != NULL) && (J->TemplateExtensions->WorkloadRMID != NULL))
    {
    /* NOTE:  job was evaluated against StageR resources but must be
              migrated to specified 'application' RM to utilize resources
    */

    if ((J->TemplateExtensions->WorkloadRM == NULL) && 
        (MRMFind(J->TemplateExtensions->WorkloadRMID,&J->TemplateExtensions->WorkloadRM) == FAILURE))
      {
      if (EMsg != NULL)
        snprintf(EMsg,MMAX_LINE,"cannot locate workload RM '%s'",
          J->TemplateExtensions->WorkloadRMID);

      return(FAILURE);
      }

    MDB(3,fSCHED) MLog("INFO:     migrating job %s to workload RM %s(evaluated against compute RM %s)\n",
      J->Name,
      J->TemplateExtensions->WorkloadRM->Name,
      (SpecR != NULL) ? SpecR->Name : "NULL");

    R = J->TemplateExtensions->WorkloadRM;
    }  /* END if ((J->TX != NULL) && (J->TX->WorkloadRMID != NULL)) */
  else
    {
    R = SpecR;
    }

  /* NOTE:  what of requests being migrated from peer-to-peer, OID should only 
            be a concern at initial source and final destination peers (NYI) */

  if (J->Credential.U->OID <= 0)
    {
    /* NOTE:  migration request on behalf of root or invalid user */

    if ((J->Credential.U->OID == 0) && (MSched.AllowRootJobs == TRUE))
      {
      /* NO-OP */
      }
    else if ((R->Type != mrmtMoab) && 
             (!bmisset(&R->Flags,mrmfDCred)) &&
             (!bmisset(&R->Flags,mrmfUserSpaceIsSeparate)) &&
             (!bmisset(&R->Flags,mrmfProxyJobSubmission)))
      {
      if (EMsg != NULL)
        {
        if (J->Credential.U->OID == 0)
          {
          sprintf(EMsg,"user '%s' not allowed to migrate jobs for submission",
            J->Credential.U->Name);
          }
        else
          {
          sprintf(EMsg,"user '%s' does not exist on local system",
            J->Credential.U->Name);
          }
        }

      if (SC != NULL)
        *SC = mscNoAuth;

      J->MigrateBlockReason = mjneBadUser;

      if (EMsg != NULL)
        {
        MUStrDup(&J->MigrateBlockMsg,EMsg);
        }
      else
        {
        MUStrDup(&J->MigrateBlockMsg,"user does not exist on local system");
        }

      return(FAILURE);
      } /* END  if ((R->Type != mrmtMoab) && (!bmisset(&R->Flags,mrmfDCred))) */

    if ((R->Type != mrmtMoab) && (bmisset(&R->Flags,mrmfDCred)))
      {
      if ((MID[0].State == mrmsActive) && (MID[0].CredCreateURL != NULL))
        {
        if (MIDUserCreate(&MID[0],J->Credential.U,J->Credential.G,EMsg) == FAILURE)
          {
          MDB(2,fSCHED) MLog("ALERT:    cannot create user '%s' - %s\n",
            J->Credential.U->Name,
            (EMsg != NULL) ? EMsg : "N/A");

          return(FAILURE);
          }
        }
      }  /* END else if ((R->Type != mrmtMoab) && ...) */
    }    /* END if (J->Cred.U->OID <= 0) */

  /* single rm migration */

  /* change internal RM reqs to new rm reqs */

  /* destination RM has been determined and set - adjust per RQ, RMIndex
   * (NOTE: do not change J->DRM until migration is successful.) */

  /* NOTE:  must handle allocation of multi-req 'extended' resources
            from within the 'shared' partition, ie network, storage, etc */

  for (rqindex = 0;J->Req[rqindex] != NULL;rqindex++)
    {
    RQ = J->Req[rqindex];

    if (MNLGetNodeAtIndex(&RQ->NodeList,0,&N) == SUCCESS)
      NRM = N->RM;
    else
      NRM = NULL;

    if (NRM != NULL)
      { 
      if (bmisset(&NRM->RTypes,mrmrtStorage) ||
          bmisset(&NRM->RTypes,mrmrtNetwork) ||
          bmisset(&NRM->RTypes,mrmrtLicense))
        {
        /* req is associated with non-compute resource */

        RQ->RMIndex = NRM->Index;

        continue;
        }
      }

    /* mjifDProcsSpecified is used to indicate dedicated procs were
     * explicitly requested. It could be that 0 dedicated procs were 
     * requested. For ex. msub -l size=0 which means in XT land that the job
     * doesn't need to go to the cray and can just run on the mom. */

    else if ((RQ->DRes.Procs == 0) && 
             (!bmisset(&J->IFlags,mjifDProcsSpecified)))
      {
      /* logical req */

      /* NOTE:  in 'instantstage' job migration, job may be migrated to
                compute RM before job nodelist is allocated - consequently,
                this block may be reached by co-alloc jobs with logical 
                resource allocations */

      if ((R == SpecR) && (bmisset(&R->RTypes,mrmrtCompute)))
        {
        /* logical req - do not assign to compute SpecR */

        continue;
        }
      }

    if (bmisset(&MRM[RQ->RMIndex].IFlags,mrmifLocalQueue))
      {
      /* job is migrating from local queue to 'real' RM */

      RQ->RMIndex = R->Index;

      continue;
      }
    }    /* END for (rqindex) */

  /* submit job to new rm */

  if (bmisset(&J->IFlags,mjifUseDRMJobID))
    {
    if (J->DRMJID != NULL)
      MUStrCpy(FullJobID,J->DRMJID,sizeof(FullJobID));
    else
      MUStrCpy(FullJobID,J->Name,sizeof(FullJobID));
    }

  /* If we are using admin exec, we need to substitute in the user's 
   * credentials into the job's initial working directory now instead of
   * later 
   * */
  if ((R->ND.AdminExec[mrmJobSubmit] == TRUE) && (J->Credential.U != NULL) 
      && (J->Credential.U->OID != MSched.UID) && (J->Env.IWD != NULL))
    {
    muenv_t E;
    char tmpLine[MMAX_LINE];

    MUEnvSetDefaults(&E,J->Credential.U->OID);
    MUInsertEnvVar(J->Env.IWD,&E,tmpLine);
    MUStrDup(&J->Env.IWD,tmpLine);
    MUEnvDestroy(&E);
    }

  if (bmisset(&J->IFlags,mjifDataOnly) &&
      bmisset(&J->Flags,mjfInteractive) &&
      ((bmisset(&R->Languages,mrmtPBS)) ||
       (bmisset(&R->SubLanguages,mrmstXT4)))) /* XT4 cluster uses torque */
    {
    /* instead of migrating the interactive job to another RM,
       get the J->SubmitString back to the msub client so it can
       fork off "qsub" */

    rc = MPBSJobSubmit(
           NULL,
           R,
           JP,         /* I/O */
           0,          /* job submit flags, (ie data only) */
           FullJobID,  /* I/O */
           EMsg,       /* O */
           SC);        /* O */
    }
  else
    {
    rc = MRMJobSubmit(
           NULL,
           R,
           JP,         /* I/O */
           0,          /* job submit flags, (ie data only) */
           FullJobID,  /* I/O */
           EMsg,       /* O */
           SC);        /* O */
    }

  /* check for failures */

  if (rc == FAILURE) 
    {
    *JP = SJ;

    if (R->Type == mrmtMoab)
      {
      /* cancel the job on the destination moab, unset the migrated flag, and put the job on batch hold */ 

      MJobUnMigrate(J,TRUE,NULL,NULL);
      }

    /* migrate failed, restore original rm */

    for (rqindex = 0;J->Req[rqindex] != NULL;rqindex++)
      {
      if (J->Req[rqindex]->RMIndex == R->Index)
        {
        if (J->SubmitRM != NULL)
          J->Req[rqindex]->RMIndex = J->SubmitRM->Index;
        }
      }    /* END for (rqindex) */

    J->MigrateBlockReason = mjneRMSubmitFailure;

    if (EMsg != NULL)
      {
      MUStrDup(&J->MigrateBlockMsg,EMsg);
      }
    else
      {
      MUStrDup(&J->MigrateBlockMsg,"cannot submit job to RM");
      }

    if ((EMsg != NULL) && 
        (strstr(EMsg,"directory")))
      {
      MUStrDup(&R->FMapEMsg,EMsg);
      }

    if ((EMsg != NULL) && 
        (strstr(EMsg,"group")))
      {
      MUStrDup(&R->CMapEMsg,EMsg);
      }

    /* has job failed at migration too many times? */

    if (J->MigrateCount >= MSched.DeferStartCount)  /* change to MSched.DeferMigrateCount? */
      {
      MDB(2,fSCHED) MLog("ALERT:    job '%s' deferred after %d failed migration attempts (API failure on last attempt)\n",
        J->Name,
        J->MigrateCount);
 
      if (MSched.Mode != msmMonitor)
        {
        if (R->Type != mrmtMoab)
          {
          /* NOTE:  only hold job if migration is to local RM */

          MJobSetHold(J,mhDefer,MSched.DeferTime,mhrAPIFailure,EMsg);
          }
        }
      }

    return(FAILURE);
    }  /* END if (rc == FAILURE) */

  /* NOTE:  In co-alloc environment, DRMJID set to remote JID for primary req */

  /* update job rm and name info */

  MJobGetName(NULL,FullJobID,R,SJobID,sizeof(SJobID),mjnShortName);

  /* SRMJID stays the same, DRMJID changes to new RM */

  MJobSetAttr(J,mjaDRMJID,(void **)FullJobID,mdfString,mSet);

  MJobSetAttr(J,mjaDRM,(void **)R,mdfOther,mSet);

  if (R->Type == mrmtMoab)
    {
    J->SubState = mjsstMigrated;
    /* update array if this is an array subjob */
    if (bmisset(&J->Flags, mjfArrayJob))
      {
      if (MJobFind(J->JGroup->Name,&JA,mjsmExtended) != FAILURE)
        {
        MJobArrayUpdate(JA);
        }
      }
    }

  /* recalculate job data dependencies */

  MSDUpdateStageInStatus(J,NULL);

  /* remove job from local queue */

  if ((J->SubmitRM != NULL) && bmisset(&J->SubmitRM->IFlags,mrmifLocalQueue))
    {
    MS3RemoveLocalJob(J->SubmitRM,J->Name);
    }

  if (MSched.JobMigratePolicy == mjmpImmediate)
    {
    /* remove the old job name from the cache */

		MCacheRemoveJob(J->Name);
    }

  if (JobID != NULL)
    MUStrCpy(JobID,SJobID,MMAX_NAME);

  /* update stats for partition allocation policies */

  P = &MPar[R->PtIndex];

  if (P != NULL)
    {
    int rqindex;
    mreq_t *RQ;

    P->MigrateTime = MSched.Time;    
    P->S.ISubmitJC++;

    /* decrement dedicated resources appropriately */

    for (rqindex = 0;J->Req[rqindex] != NULL;rqindex++)
      {
      RQ = J->Req[rqindex];

      if (RQ == NULL)
        break;

      MCResAdd(&P->DRes,&P->CRes,&RQ->DRes,RQ->TaskCount,FALSE);
      MCResRemove(&P->ARes,&P->CRes,&RQ->DRes,RQ->TaskCount,FALSE);
      }  /* END for (rqindex) */
    }    /* END if (P != NULL) */
  
  /* remove original job? */

  if (DoPurgeSource == TRUE)
    {
    /* remove/destroy job as if it never existed - Moab will rediscover effective job via RM */

    MJobRemove(JP);

    return(SUCCESS);
    }

  /* write out event */

  MOWriteEvent((void *)J,mxoJob,mrelJobMigrate,NULL,MStat.eventfp,NULL);
  
  /* force a checkpoint to preserve new RM relationships */

  MCP.LastCPTime = 0;

  /* remove interim checkpoint file */

  /* NOTE:  added R->Type constraint on Aug 30, 2005 */

  if ((J->SubmitRM != NULL) &&
      (R->Type != mrmtMoab) &&
     ((bmisset(&J->SubmitRM->IFlags,mrmifLocalQueue)) ||
      (bmisset(&J->SubmitRM->Flags,mrmfFullCP))))
    {
    /* remove checkpoint file if job is staged to final destination RM */
    /* final destination RM (ie, TORQUE, LSF, SGE) will manage and report */
    /* job from here on out */

    MJobRemoveCP(J);
    }

  if (MSched.LimitedJobCP == FALSE)
    MJobTransition(J,TRUE,FALSE);

  return(SUCCESS);
  }  /* END MJobMigrate() */




/**
 * This routine un-migrates the job by canceling the job on any remote RMs it was staged
 * to, reseting the state to Idle, adding it back to the "internal" queue, etc.
 * 
 * @param J (I) The job to unmigrate.
 * @param DoClearHolds (I) Whether or not the job's holds should be cleared after unmigration
 * @param EMsg (O) [optional,minsize=MMAX_LINE]
 * @param SC (O) [optional] 
 */

int MJobUnMigrate(

  mjob_t  *J,             /* I */
  mbool_t  DoClearHolds,  /* I */
  char    *EMsg,          /* O (optional,minsize=MMAX_LINE) */
  int     *SC)            /* O (optional) */

  {
  mrm_t  *InternalRM;
  mreq_t *RQ;
  int     rqindex;
  
  const char *FName = "MJobUnMigrate";

  MDB(7,fSCHED) MLog("%s(%s,%d,EMsg,SC)\n",
    FName,
    (J != NULL) ? J->Name : NULL,
    DoClearHolds);

  if (EMsg != NULL)
    EMsg[0] = '\0';

  if (J == NULL)
    {
    return(FAILURE);
    }

  /* use the force so that it purges it (and the SJID) from the RM */

  bmset(&J->IFlags,mjifRequestForceCancel);

  /* if Moab RM, job has been rescheduled already so cancel would fail */

  if ((J->DestinationRM != NULL) && 
      (J->DestinationRM->Type != mrmtMoab) && 
      (MJobCancel(J,NULL,TRUE,EMsg,SC) == FAILURE))
    {
    return(FAILURE);
    }

  if (MJobToIdle(J,DoClearHolds,TRUE) == FAILURE)
    {
    if (EMsg != NULL)
      MUStrCpy(EMsg,"could not return job to idle state\n",MMAX_LINE);

    return(FAILURE);
    }

  MRMGetInternal(&InternalRM);

  /* reset partition mask */

  bmclear(&J->PAL);
/* don't mess with user specified PAL (MOAB-4207)
  bmclear(&J->SpecPAL);
*/
  MJobGetPAL(J,&J->SpecPAL,&J->SysPAL,&J->PAL);

  /* reset nodes */

  MNLClear(&J->NodeList);
  MNLClear(&J->Req[0]->NodeList);

  /* job must be added to local queue on internal RM or it will be marked as stale
   * and removed */

  if (MS3AddLocalJob(InternalRM,J->Name) == FAILURE)
    {
    if (EMsg != NULL)
      MUStrCpy(EMsg,"could not add job to internal queue\n",MMAX_LINE);

    return(FAILURE);
    }

  /* MJobToIdle() set the req RMIndex to -1 - we need to set it back to the internal queue 
     (similar to what is done in MUIJobSubmit() when setting up the req rm index) */

  for (rqindex = 0;rqindex < MMAX_REQ_PER_JOB;rqindex++)
    {
    RQ = J->Req[rqindex];

    if (RQ == NULL)
      break;

    RQ->RMIndex = InternalRM->Index;  /* setting RMIndex to local queue */
    }  /* END for (rqindex) */

  return(SUCCESS);
  }  /* END MJobUnMigrate() */





/**
 * Update job and node attributes associated with node allocation

 * NOTE: this function does not seem to work properly if the job
 * is running on both the SrcN and DstN, which is possible
 */

int MJobMigrateNode(

  mjob_t  *J,     /* I (modified) */
  mvm_t   *V,     /* I (optional) */
  mnode_t *SrcN,  /* I */
  mnode_t *DstN)  /* I */

  {
  int nindex;
  int rqindex;

  mreq_t *RQ;

  mnl_t tmpNL = {0};

  mnode_t *N;

  if ((J == NULL) || (SrcN == NULL) || (DstN == NULL))
    {
    return(FAILURE);
    }

  if (MJOBISALLOC(J) == FALSE)
    {
    return(SUCCESS);
    }

  /* replace SrcN with DstN in J->NodeList, J->Req[]->NodeList, and J->TaskMap */

  if (!MNLIsEmpty(&J->NodeList))
    {
    for (nindex = 0;MNLGetNodeAtIndex(&J->NodeList,nindex,&N) == SUCCESS;nindex++)
      {
      if (N == SrcN)
        {
        MNLSetNodeAtIndex(&J->NodeList,nindex,DstN);

        break;
        }
      }
    }

  if (J->TaskMap != NULL)
    {
    for (nindex = 0;J->TaskMap[nindex] != -1;nindex++)
      {
      if (J->TaskMap[nindex] == SrcN->Index)
        {
        J->TaskMap[nindex] = DstN->Index;

        break;
        }
      }
    }

  for (rqindex = 0;J->Req[rqindex] != NULL;rqindex++)
    {
    RQ = J->Req[rqindex];

    if (MNLIsEmpty(&RQ->NodeList))
      continue;

    for (nindex = 0;MNLGetNodeAtIndex(&RQ->NodeList,nindex,&N) == SUCCESS;nindex++)
      {
      if (N == SrcN)
        {
        MNLSetNodeAtIndex(&RQ->NodeList,nindex,DstN);

        break;
        }
      }
    }    /* END for (rqindex) */
    
  /* remove J from SrcN->JList */

  MNLInit(&tmpNL);

  MNLSetNodeAtIndex(&tmpNL,0,SrcN);
  MNLSetTCAtIndex(&tmpNL,0,1);

  MJobRemoveFromNL(J,&tmpNL);

  /* add J to DstN->JList */

  MNLSetNodeAtIndex(&tmpNL,0,DstN);

  MJobAddToNL(J,&tmpNL,FALSE);

  MNLFree(&tmpNL);

  if (J->Rsv != NULL)
    {
    /* adjust J->R to reflect new allocation */

    enum MJRsvSubTypeEnum RsvSType;
   
    RsvSType = J->RType;
 
    /* need to release all sub reservations */

    MJobReleaseRsv(J,FALSE,FALSE);

    MRsvJCreate(J,NULL,J->StartTime,RsvSType,NULL,FALSE);
    }

  if ((V != NULL) && (MSched.VMGResMap == TRUE))
    {
    /* NOTE:  should create GRes map only if GRes is not workload locked (ie
              not one-time use, no ondemand created) */

    int gindex;

    gindex = MUMAGetIndex(meGRes,V->VMID,mAdd);

    if ((gindex > 0) && (MSNLGetIndexCount(&DstN->CRes.GenericRes,gindex) == 0))
      {
      /* add VM map GRes */

      MSNLSetCount(&DstN->CRes.GenericRes,gindex,1);
      MSNLSetCount(&DstN->ARes.GenericRes,gindex,1);
      MSNLSetCount(&DstN->DRes.GenericRes,gindex,0);
      }

    MSNLSetCount(&SrcN->CRes.GenericRes,gindex,0);
    MSNLSetCount(&SrcN->ARes.GenericRes,gindex,0);
    MSNLSetCount(&SrcN->DRes.GenericRes,gindex,0);
    }

  return(SUCCESS);
  }  /* END MJobMigrateNode() */
/* END MJobMigrate.c */
